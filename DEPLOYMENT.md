# GuerrillaTime Deployment Guide

## Overview
This guide covers the deployment of GuerrillaTime to GitHub Container Registry using Nixpacks and Docker.

## Prerequisites

### Local Development
1. **Docker** - Install Docker Desktop
2. **Nixpacks** - Install via curl:
   ```bash
   curl -sSL https://nixpacks.com/install.sh | bash
   ```
3. **GitHub Personal Access Token** with `packages:write` permission

### Environment Setup
1. Create a `.env` file in the project root:
   ```env
   GITHUB_TOKEN=your_github_token_here
   ```

## Deployment Methods

### Method 1: Local Build Script

#### For Unix/Linux/macOS:
```bash
chmod +x build.sh
./build.sh
```

#### For Windows (PowerShell):
```powershell
.\build.ps1
```

### Method 2: GitHub Actions (Recommended)
The repository includes an automated GitHub Actions workflow that:
- Triggers on push to main/master branch
- Builds the application with Nixpacks
- Pushes to GitHub Container Registry
- Provides deployment notifications

To use:
1. Push your code to the main/master branch
2. GitHub Actions will automatically build and deploy
3. Check the Actions tab for deployment status

## Container Registry Information

- **Registry**: `ghcr.io`
- **Repository**: `ghcr.io/digital-guerrilla/guerrillatime`
- **Tags**: `latest` for main branch

## Running the Deployed Container

### Pull and Run:
```bash
# Pull the latest image
docker pull ghcr.io/digital-guerrilla/guerrillatime:latest

# Run the container
docker run -p 8000:8000 \
  -e PORT=8000 \
  -e SECRET_KEY=your_secret_key \
  -e DATABASE_URL=your_database_url \
  ghcr.io/digital-guerrilla/guerrillatime:latest
```

### Docker Compose Example:
```yaml
version: '3.8'
services:
  guerrillatime:
    image: ghcr.io/digital-guerrilla/guerrillatime:latest
    ports:
      - "8000:8000"
    environment:
      - PORT=8000
      - SECRET_KEY=${SECRET_KEY}
      - DATABASE_URL=${DATABASE_URL}
    restart: unless-stopped
```

## Configuration Files

### `gunicorn_config.py`
Production-ready Gunicorn configuration with:
- Automatic worker scaling based on CPU cores
- Proper logging configuration
- Memory leak prevention
- Health check timeouts

### `nixpacks.toml`
Nixpacks build configuration:
- Python 3.10 runtime
- Automatic dependency installation
- Database initialization during build
- Optimized start command

## Docker/Nixpacks Deployment

This application is configured for deployment using Gunicorn WSGI server within a Docker container generated by nixpacks.

### Quick Start

#### Option 1: Automated Deployment (Recommended)

**Linux/macOS:**
```bash
# Make script executable
chmod +x deploy.sh

# Run deployment script
./deploy.sh
```

**Windows:**
```cmd
# Run deployment script
deploy.bat
```

**Quick Deploy (uses defaults):**
```bash
# For rapid testing with default credentials
chmod +x quick-deploy.sh
./quick-deploy.sh
```

#### Option 2: Manual Deployment

1. **Environment Variables**: Set these required environment variables:
   ```bash
   SECRET_KEY=your-strong-32-char-secret-key
   ADMIN_EMAIL=admin@yourcompany.com
   ADMIN_PASSWORD=your-strong-admin-password
   API_KEY=your-secure-api-key
   PORT=5000
   ```

2. **Deploy**: The application will automatically:
   - Install dependencies from `requirements.txt`
   - Initialize the SQLite database
   - Start with Gunicorn WSGI server
   - Listen on `0.0.0.0:$PORT`

### Security Considerations

#### Environment Variables
Generate secure values for production:

```bash
# Generate SECRET_KEY
python -c "import secrets; print(secrets.token_hex(32))"

# Generate API_KEY  
python -c "import secrets; print('timesheet-api-' + secrets.token_urlsafe(32))"
```

#### Required Environment Variables
```bash
SECRET_KEY=                    # 32+ character random string
ADMIN_EMAIL=                   # Admin user email
ADMIN_PASSWORD=                # Strong admin password
API_KEY=                       # Secure API key for Power BI
DATABASE=timesheet.db          # Database file path
```

#### Optional Environment Variables
```bash
FLASK_ENV=production          # Set to production
FLASK_DEBUG=false            # Disable debug mode
PORT=5000                    # Port number (default: 5000)
```

### File Structure

```
Guerrilla-T/
├── wsgi.py                  # WSGI entry point for Gunicorn
├── run.py                   # Development entry point
├── deploy.sh                # Linux/macOS deployment script
├── deploy.bat               # Windows deployment script  
├── quick-deploy.sh          # Quick deployment with defaults
├── Procfile                 # Process definition for deployment
├── nixpacks.toml           # Nixpacks configuration
├── requirements.txt         # Python dependencies (includes gunicorn)
├── .env.production         # Production environment template
├── app/                    # Application package
└── static/                 # Static assets
```

### Deployment Process

#### Automated Scripts

The deployment scripts handle the entire process:

1. **Prerequisites Check**:
   - Verify nixpacks installation
   - Verify Docker is running
   - Generate secure secrets automatically

2. **Configuration**:
   - Prompt for admin credentials
   - Generate strong SECRET_KEY and API_KEY
   - Configure environment variables

3. **Build & Deploy**:
   - Build Docker image with nixpacks
   - Create data directory for database persistence
   - Stop/remove any existing containers
   - Start new container with proper configuration

#### Manual Process

1. **Nixpacks Build Phase**:
   - Detects Python application
   - Installs dependencies from `requirements.txt`
   - Initializes SQLite database

2. **Runtime Phase**:
   - Starts Gunicorn with 2 workers
   - Binds to `0.0.0.0:$PORT`
   - Serves WSGI application

### Health Checks

The application includes a health check endpoint:
- **URL**: `/health`
- **Response**: JSON with status and timestamp
- **Use**: Container orchestration health checks

### Database Persistence

- **SQLite Database**: `timesheet.db` file
- **Location**: Application root directory
- **Backup**: Ensure database file is included in persistent storage
- **Initialization**: Automatic on first run

### Gunicorn Configuration

Default configuration (from `Procfile`):
```bash
gunicorn wsgi:application --bind 0.0.0.0:$PORT --workers 2 --timeout 60 --keep-alive 2
```

#### Configuration Options:
- **Workers**: 2 (adjust based on CPU cores)
- **Timeout**: 60 seconds
- **Keep-alive**: 2 seconds
- **Binding**: All interfaces on specified port

### Monitoring & Logging

- **Application Logs**: Sent to stdout (captured by container)
- **Health Endpoint**: `/health` for monitoring
- **Log Level**: INFO in production
- **Format**: Timestamped with log level and message

### Production Checklist

- [ ] Set strong `SECRET_KEY`
- [ ] Set secure `API_KEY` 
- [ ] Use strong admin password
- [ ] Configure proper domain/SSL
- [ ] Set up database backups
- [ ] Configure monitoring/alerts
- [ ] Test health check endpoint
- [ ] Verify environment variables
- [ ] Test OAuth configuration (if used)
- [ ] Validate 2FA functionality

### Scaling Considerations

- **Database**: SQLite works well for small-medium teams
- **Workers**: Scale Gunicorn workers based on CPU cores
- **Static Files**: Consider CDN for larger deployments
- **Session Storage**: Flask-Login sessions stored server-side

### Troubleshooting

#### Common Issues:

1. **Database Permissions**: Ensure container can write to database location
2. **Port Binding**: Verify `PORT` environment variable is set
3. **Environment Variables**: Check all required vars are configured
4. **Static Files**: Ensure static directory is accessible

#### Debug Mode:
```bash
FLASK_DEBUG=true  # Enable only for debugging
```

#### Logs:
```bash
# View container logs
docker logs <container-id>

# Health check
curl http://localhost:5000/health
```

### Security Notes

- Debug mode is disabled in production
- Passwords hashed with bcrypt
- API endpoints require Bearer token authentication
- SQL injection protection via parameterized queries
- CSRF protection in OAuth flows
- Session management via Flask-Login
